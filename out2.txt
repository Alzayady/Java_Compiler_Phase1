Stack: $ METHOD_BODY 
Current_state: METHOD_BODY
Current token: int
Log: METHOD_BODY -->  STATEMENT_LIST
Stack: $ STATEMENT_LIST 
Current_state: STATEMENT_LIST
Current token: int
Log: STATEMENT_LIST -->  STATEMENT STATEMENT_LIST2
Stack: $ STATEMENT_LIST2 STATEMENT 
Current_state: STATEMENT
Current token: int
Log: STATEMENT -->  DECLARATION
Stack: $ STATEMENT_LIST2 DECLARATION 
Current_state: DECLARATION
Current token: int
Log: DECLARATION -->  PRIMITIVE_TYPE id ;
Stack: $ STATEMENT_LIST2 ; id PRIMITIVE_TYPE 
Current_state: PRIMITIVE_TYPE
Current token: int
Log: PRIMITIVE_TYPE -->  int
Stack: $ STATEMENT_LIST2 ; id int 
Current_state: int
Current token: int
matching the token int
Stack: $ STATEMENT_LIST2 ; id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 ; 
Current_state: ;
Current token: ;
matching the token ;
Stack: $ STATEMENT_LIST2 
Current_state: STATEMENT_LIST2
Current token: id
Log: STATEMENT_LIST2 -->  STATEMENT STATEMENT_LIST2
Stack: $ STATEMENT_LIST2 STATEMENT 
Current_state: STATEMENT
Current token: id
Log: STATEMENT -->  ASSIGNMENT
Stack: $ STATEMENT_LIST2 ASSIGNMENT 
Current_state: ASSIGNMENT
Current token: id
Log: ASSIGNMENT -->  id = EXPRESSION ;
Stack: $ STATEMENT_LIST2 ; EXPRESSION = id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 ; EXPRESSION = 
Current_state: =
Current token: assign
missing assign the token.  assign inserted
Stack: $ STATEMENT_LIST2 ; EXPRESSION 
Current_state: EXPRESSION
Current token: num
Log: EXPRESSION -->  SIMPLE_EXPRESSION EXPRESSION2
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: num
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: num
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: num
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: num
Log: FACTOR -->  num
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 num 
Current_state: num
Current token: num
matching the token num
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: ;
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: ;
Log: SIMPLE_EXPRESSION3 -->  \L
Stack: $ STATEMENT_LIST2 ; EXPRESSION2 
Current_state: EXPRESSION2
Current token: ;
Log: EXPRESSION2 -->  \L
Stack: $ STATEMENT_LIST2 ; 
Current_state: ;
Current token: ;
matching the token ;
Stack: $ STATEMENT_LIST2 
Current_state: STATEMENT_LIST2
Current token: if
Log: STATEMENT_LIST2 -->  STATEMENT STATEMENT_LIST2
Stack: $ STATEMENT_LIST2 STATEMENT 
Current_state: STATEMENT
Current token: if
Log: STATEMENT -->  IF
Stack: $ STATEMENT_LIST2 IF 
Current_state: IF
Current token: if
Log: IF -->  if ( EXPRESSION ) { STATEMENT } else { STATEMENT }
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION ( if 
Current_state: if
Current token: if
matching the token if
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION ( 
Current_state: (
Current token: (
matching the token (
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION 
Current_state: EXPRESSION
Current token: id
Log: EXPRESSION -->  SIMPLE_EXPRESSION EXPRESSION2
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: id
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: id
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: id
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: id
Log: FACTOR -->  id
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: relop
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: relop
Log: SIMPLE_EXPRESSION3 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) EXPRESSION2 
Current_state: EXPRESSION2
Current token: relop
Log: EXPRESSION2 -->  relop SIMPLE_EXPRESSION
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION relop 
Current_state: relop
Current token: relop
matching the token relop
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: num
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: num
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: num
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: num
Log: FACTOR -->  num
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION3 TERM2 num 
Current_state: num
Current token: num
matching the token num
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: )
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: )
Log: SIMPLE_EXPRESSION3 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { ) 
Current_state: )
Current token: )
matching the token )
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT { 
Current_state: {
Current token: {
matching the token {
Stack: $ STATEMENT_LIST2 } STATEMENT { else } STATEMENT 
Current_state: STATEMENT
Current token: id
Log: STATEMENT -->  ASSIGNMENT
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ASSIGNMENT 
Current_state: ASSIGNMENT
Current token: id
Log: ASSIGNMENT -->  id = EXPRESSION ;
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION = id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION = 
Current_state: =
Current token: assign
missing assign the token.  assign inserted
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION 
Current_state: EXPRESSION
Current token: num
Log: EXPRESSION -->  SIMPLE_EXPRESSION EXPRESSION2
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: num
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: num
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: num
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: num
Log: FACTOR -->  num
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 num 
Current_state: num
Current token: num
matching the token num
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: ;
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: ;
Log: SIMPLE_EXPRESSION3 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; EXPRESSION2 
Current_state: EXPRESSION2
Current token: ;
Log: EXPRESSION2 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { else } ; 
Current_state: ;
Current token: ;
matching the token ;
Stack: $ STATEMENT_LIST2 } STATEMENT { else } 
Current_state: }
Current token: }
matching the token }
Stack: $ STATEMENT_LIST2 } STATEMENT { else 
Current_state: else
Current token: else
matching the token else
Stack: $ STATEMENT_LIST2 } STATEMENT { 
Current_state: {
Current token: {
matching the token {
Stack: $ STATEMENT_LIST2 } STATEMENT 
Current_state: STATEMENT
Current token: id
Log: STATEMENT -->  ASSIGNMENT
Stack: $ STATEMENT_LIST2 } ASSIGNMENT 
Current_state: ASSIGNMENT
Current token: id
Log: ASSIGNMENT -->  id = EXPRESSION ;
Stack: $ STATEMENT_LIST2 } ; EXPRESSION = id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 } ; EXPRESSION = 
Current_state: =
Current token: assign
missing assign the token.  assign inserted
Stack: $ STATEMENT_LIST2 } ; EXPRESSION 
Current_state: EXPRESSION
Current token: num
Log: EXPRESSION -->  SIMPLE_EXPRESSION EXPRESSION2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: num
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: num
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: num
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: num
Log: FACTOR -->  num
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 num 
Current_state: num
Current token: num
matching the token num
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: ;
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: ;
Log: SIMPLE_EXPRESSION3 -->  \L
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 
Current_state: EXPRESSION2
Current token: ;
Log: EXPRESSION2 -->  \L
Stack: $ STATEMENT_LIST2 } ; 
Current_state: ;
Current token: ;
matching the token ;
Stack: $ STATEMENT_LIST2 } 
Current_state: }
Current token: }
matching the token }
Stack: $ STATEMENT_LIST2 
Current_state: STATEMENT_LIST2
Current token: while
Log: STATEMENT_LIST2 -->  STATEMENT STATEMENT_LIST2
Stack: $ STATEMENT_LIST2 STATEMENT 
Current_state: STATEMENT
Current token: while
Log: STATEMENT -->  WHILE
Stack: $ STATEMENT_LIST2 WHILE 
Current_state: WHILE
Current token: while
Log: WHILE -->  while ( EXPRESSION ) { STATEMENT }
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION ( while 
Current_state: while
Current token: while
matching the token while
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION ( 
Current_state: (
Current token: (
matching the token (
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION 
Current_state: EXPRESSION
Current token: id
Log: EXPRESSION -->  SIMPLE_EXPRESSION EXPRESSION2
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: id
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: id
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: id
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: id
Log: FACTOR -->  id
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: )
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: )
Log: SIMPLE_EXPRESSION3 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { ) EXPRESSION2 
Current_state: EXPRESSION2
Current token: )
Log: EXPRESSION2 -->  \L
Stack: $ STATEMENT_LIST2 } STATEMENT { ) 
Current_state: )
Current token: )
matching the token )
Stack: $ STATEMENT_LIST2 } STATEMENT { 
Current_state: {
Current token: {
matching the token {
Stack: $ STATEMENT_LIST2 } STATEMENT 
Current_state: STATEMENT
Current token: id
Log: STATEMENT -->  ASSIGNMENT
Stack: $ STATEMENT_LIST2 } ASSIGNMENT 
Current_state: ASSIGNMENT
Current token: id
Log: ASSIGNMENT -->  id = EXPRESSION ;
Stack: $ STATEMENT_LIST2 } ; EXPRESSION = id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 } ; EXPRESSION = 
Current_state: =
Current token: assign
missing assign the token.  assign inserted
Stack: $ STATEMENT_LIST2 } ; EXPRESSION 
Current_state: EXPRESSION
Current token: id
Log: EXPRESSION -->  SIMPLE_EXPRESSION EXPRESSION2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION 
Current_state: SIMPLE_EXPRESSION
Current token: id
Log: SIMPLE_EXPRESSION -->  SIMPLE_EXPRESSION2 SIMPLE_EXPRESSION3
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: id
Log: SIMPLE_EXPRESSION2 -->  TERM
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM 
Current_state: TERM
Current token: id
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 FACTOR 
Current_state: FACTOR
Current token: id
Log: FACTOR -->  id
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 id 
Current_state: id
Current token: id
matching the token id
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 TERM2 
Current_state: TERM2
Current token: addop
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION3 
Current_state: SIMPLE_EXPRESSION3
Current token: addop
Log: SIMPLE_EXPRESSION3 -->  addop TERM SIMPLE_EXPRESSION2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION2 TERM addop 
Current_state: addop
Current token: addop
matching the token addop
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION2 TERM 
Current_state: TERM
Current token: num
Log: TERM -->  FACTOR TERM2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION2 TERM2 FACTOR 
Current_state: FACTOR
Current token: num
Log: FACTOR -->  num
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION2 TERM2 num 
Current_state: num
Current token: num
matching the token num
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION2 TERM2 
Current_state: TERM2
Current token: ;
Log: TERM2 -->  \L
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 SIMPLE_EXPRESSION2 
Current_state: SIMPLE_EXPRESSION2
Current token: ;
Log: ;is in the recovering, we are going to pop SIMPLE_EXPRESSION2
Stack: $ STATEMENT_LIST2 } ; EXPRESSION2 
Current_state: EXPRESSION2
Current token: ;
Log: EXPRESSION2 -->  \L
Stack: $ STATEMENT_LIST2 } ; 
Current_state: ;
Current token: ;
matching the token ;
Stack: $ STATEMENT_LIST2 } 
Current_state: }
Current token: }
matching the token }
Stack: $ STATEMENT_LIST2 
Current_state: STATEMENT_LIST2
Current token: $
Log: STATEMENT_LIST2 -->  \L
Stack: $ 
Current_state: $
Current token: $
accept the string :)
DONE!
